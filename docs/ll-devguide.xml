<?xml version='1.0' encoding='iso-8859-1'?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"
[<!ENTITY llversion '3.0.28'>]>

<!--
Outline for developer's guide to lifelines code.
This is only an outline, not a parseable XML file.

2003-03-24, Perry Rapp


* stdlib module
The stdlib directory contains various utility functions not specifically
related to LifeLines, GEDCOM, or even genealogy.

  * string functions
  There has built up, over time, quite an assortment of string functions,
  split currently between mystring.c and stdstrng.c (and a few macros in
  standard.h).

    * llstrncpy, llstrncat
    These are simple wrappers around the C RTL (run time library) functions.
    The ANSI versions do not zero-terminate on overflow, which is greatly
    inconvenient, os the wrapper versions do so. Also, the wrapper versions
    are UTF-8 aware (they backtrack on overflow, to avoid leaving part of
    a UTF-8 multibyte sequence at the end).

    * llstrapp (string append)
    This family of functions is one (thin) layer higher than llstrncpy,
    providing an interface wherein the caller specified the buffer's start
    and entire size. That is,
      llstrncat(buffer, " more stuff", sizeof(buffer)-strlen(buffer));
    may be replaced by
      llstrapp(buffer, sizeof(buffer), " more stuff");
    There are also varargs versions, so that
      snprintf(buffer+strlen(buffer), sizeof(buffer)-strlen(buffer), ...
    may be replaced by
      llstrappf(buffer, sizeof(buffer), ...

    * appendstr
    This is a family of functions similar in purpose to the strapp 
    family, but which uses an additional level of indirection, advancing
    pointers and decrementing counts. 

      * NOTE: FUTURE DIRECTIONS
      I put these in, and I would like to take them out, as I find them
      less intuitive than the strapp family, and more bug-prone. They are
      slightly faster, but I don't think it is worth it. -Perry. 

    * char functions
    There are character classification functions, which have handling
    particular to Latin-1 and to Finnish (if the Finnish compilation option
    was set). 

      * NOTE: FUTURE DIRECTIONS
      It would be very nice to see wchar-based functions, which handle
      unicode, replace these, and then we might be able to jettison the
      Latin-1 & Finnish specific character code.

    * string allocation functions
    TODO: (strsave, strfree, strupdate, strconcat, free_array_strings)

    * string conversion functions
    TODO: (isnumeric, lower, upper, capitalize, titlecase)

    * string equality functions
    TODO: (eqstr, eqstr_ex, nestr, cmpstr)

    * string comparison function
    TODO: (cmpstrloc)

    * string whitespace functions
    TODO: (trim, striptrail, striplead, allwhite, chomp)

    * string UTF-8 functions
    TODO: (utf8len, find_prev_char)

    * printpic functions
    TODO: (sprintpic0,1,2,3)

* gedlib module
This directory is a collection of routines for GEDCOM and for its use in
a LifeLines btree database.

  * names
  This module implements indexing names.
  TODO: Explain soundex indexing.

  * refns
  This module implements indexing references (REFNs).
  TOD: Explain two character index.

  * xreffile
  This module stores lists of deleted record numbers for each type.
  When a record is deleted, its number is added to the appropriate
  deleted list in xreffile. When a record is added, first the
  appropriate deleted list in xreffile is checked for a free record
  number.

  * messages
  Traditionally all translatable strings have been stored in this file.
  This is not necessary with the current gettext scheme, but it would
  perhaps be helpful if a resource based scheme were adapted in the
  future.

    * FUTURE DIRECTIONS
    When/If GUI versions are incorporated into the same codebase, how to
    handle translate strings shared and not shared between versions needs
    to be worked out.

  * translation tables (charmaps.c & translat.c)
  The implementation of codeset translation is stored here (not to be 
  confused with language translation for the user interface, called
  localization, and not associated with these files). Both custom
  translation tables and delegation to the iconv codeset conversion 
  library are done here.

  * indiseq
  The indiseq type is implemented here, a list of records (which no longer
  need all be persons).

  * brwslist
  Named browse lists are implemented here (temporary record lists named by
  user during this session).

* interp module
The lifelines reporting language parser and interpreter are stored here.
A custom lexical analyzer is in lex.c, and a yacc parser generator is
in yacc.y. 

The main interpreter is called with a list of files to parse, and some
options. In actuality, I don't think more than one file is ever passed
to the main entry point. If no file is passed, the routine will prompt
(and here is where the user may choose a report from a list). But a
report may be passed in, if one was specified with commandline argument
to llines or llexec.

The report file is parsed, and as it is parsed, any included reports 
are added to the list to be parsed (unless already on the list,
so circular references are not a problem).

require statements are handled at parse time. The handler puts the
requested version into the file property table (stored inside the
pointer in the filetab entry for the file; filetab entries are
indexed by full path of report). Later, just after parse completes
for that file (in the main parsing loop in the main interpreter 
function), require conditions are tested in check_rpt_requires(...).

  * pvalues
  All variable values in report language interpretation are stored in a
  union type called pvalue.

  * symtab
  Symbol tables are a thin wrapper around the table type provided by
  stdlib, specialized to hold pvalues.

  * date
  A fairly complete GEDCOM date parser is also located here. It actually
  includes both a date parser, and a date formatter (which generates the
  thousands of possible lifelines date formats).

    * FUTURE DIRECTIONS
    If a date type were added to the report language, it would be possible
    to distinguish fully-parsed dates in the report language (so invalid or
    illegal dates could be flagged & handled separately in a report). The
    date module already implements a date type internally, and it is
    exposed to the rest of the program (gdate & gdate_val, which correspond
    to GEDCOM date types), but not to the report language.

* liflines module
TODO:

-->



  <book id="docbook">

  <bookinfo>


<!--

    this is ll-devguide.xml

    To use this file with SGML software, replace the text above
    this comments section with the following:

_________________________________________________________

<!DOCTYPE BOOK PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
	<!entity llversion	"3.0.25">
]>	
	
<book id="docbook">
  <?dbhtml filename="ll-doc.htm">
  <bookinfo>
_________________________________________________________


                                                       -->
<!-- ================================================= -->

    <title>

<application>LifeLines</application> Developer Documentation
</title>

    <authorgroup>
      <author>
      <firstname>Perry</firstname><surname>Rapp </surname>
      </author>
    </authorgroup>

    <subtitle><application>LifeLines</application> Version &llversion;</subtitle>
  </bookinfo>



    <chapter><title>

Introduction to Lifelines Developers Manual

</title>


<para>

     <application>LifeLines</application> source code is divided into
	 several functional subdirectories, which will be discussed 
	 individually below. They are chained together by an autotools
	 build system, which creates executables in both the liflines
	 and tools subdirectories.

</para>

</chapter>
<chapter>
<title>btree module</title>

<para>
  The btree subdirectory contains the implementation for a btree
  database, using fixed length 8 letter keys (RKEY).
</para>

<formalpara>
<title>nodes</title>
<para>
  Each node in the btree is a separate file on disk (named, eg, "aa"),
  and the first 4096 (BUFLEN macro) bytes are the node header.
</para></formalpara>

<formalpara><title>

  index nodes

    </title><para>

  These are the interior index nodes of the btree; they contain pointers
  to subordinate index or block nodes. The program performs binary
  searches through index nodes to find a particular key.

    </para></formalpara><formalpara><title>

  block nodes

    </title><para>

  These contain the actual data (keys & their associated records).

    </para></formalpara><formalpara><title>

  keyfile

    </title><para>

  One special file on the disk, the keyfile, contains some meta information
  and a pointer to the root of the btree (the master key). When the root
  changes (splits), the master key in the keyfile is updated accordingly.

    </para></formalpara><formalpara><title>

  traverse

    </title><para>

  There is a traversal function implemented at the btree level, which uses
  a callback.

    </para></formalpara><formalpara><title>

  bterrno

    </title><para>

  There is a global integer error variable, bterrno, which is set by this
  module upon most failure conditions.

    </para></formalpara><formalpara><title>

  FUTURE DIRECTIONS

    </title><para>

  bterrno must be removed for multi-threading. Traversal is more elegantly
  done via iterator style repeated calls in, instead of callback.

    </para></formalpara>

</chapter>
</book>
